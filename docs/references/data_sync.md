---
sidebar_position: 2
---

# 数据同步

对于任何本地优先应用来说，数据同步都是一个困难的问题。

## 序列化数据

要想实现数据同步，我们首先要实现同步数据的序列化，Limbo 采用了 Redux 的思路来解决同步数据序列化的问题：在 Redux 中，如果 Reducer 不变，执行完相同的 Actions 以后，Store 的状态总是相同的。

把这个思路代换到 Limbo 中，只要我们能保证 Reducer 不变时，处理相同的 Actions，数据库总能得到一样的内容，那么我们就可以实现数据同步。

## 逻辑时钟

在序列化问题解决以后，我们还需要解决操作时序的问题：有时一个操作可能很早就发生了，但过了很久才进行同步，这时我们应该怎么保证经过同步的 Action 能以正确的顺序进行排列？

在通常的中心化应用中，我们可以通过中心化应用提供的锁，来保证我们总是只写入最新的数据。但 Limbo 是一个去中心化应用，无法由一个绝对可信的单一端点来帮助用户完成写入，那要怎么解决操作时序上的冲突呢？

Limbo 在这个问题上借鉴了 Yjs，通过构建一个基于逻辑时钟的 CRDT 来存储序列化数据链表，这样一来序列化数据的时序就统一了。

## 回滚操作

在数据同步过程中，理想条件下我们只需要向 Store 添加最新的 Action，然后 Reducer 会应用最新的 Action，然后我们的 Store 就能保持在最新的状态。

但真实情况下，我们有时很有可能需要去同步一些“过时”的数据，当有一条过时的数据试图写入 Store 时，我们应当如何处理？

最简单的做法当然是重置 Store 然后应用包含过时数据在内的全部 Action，但这对于数据库来说开销太大了，因为一个数据库中可能存在数十万甚至数百万条 Action，如果每次都全量重构，那同步过程将变得相当漫长。

因此 Limbo 模仿 Quill 实现了一种类似 Delta 的数据结构帮助 Store 进行回滚，如此一来，就算有过时的数据写入 Store，Store 也可以只回滚和重构部分数据，这样一来就大大降低了数据同步的开销。
